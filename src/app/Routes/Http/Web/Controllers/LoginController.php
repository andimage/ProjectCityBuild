<?php

namespace App\Routes\Http\Web\Controllers;

use App\Routes\Http\Web\WebController;
use Illuminate\Validation\Factory as Validation;
use App\Modules\Forums\Services\Authentication\DiscourseAuthService;
use Illuminate\Http\Request;
use Illuminate\Contracts\Auth\Guard as Auth;
use App\Modules\Forums\Exceptions\BadSSOPayloadException;

class LoginController extends WebController {

    /**
     * @var DiscourseAuthService
     */
    private $discourseAuthService;

    /**
     * @var Auth
     */
    private $auth;


    public function __construct(
        DiscourseAuthService $discourseAuthService,
        Auth $auth
    ) {
        $this->discourseAuthService = $discourseAuthService;
        $this->auth = $auth;
    }

    public function showLoginView(Request $request) {
        // login route should have a valid payload in the url
        // generated by discourse when being redirected here
        $sso        = $request->get('sso');
        $signature  = $request->get('sig');

        if($sso === null || $signature === null) {
            return redirect()->route('front.home');
        }

        // validate that the given signature matches the
        // payload when signed with our private key. This
        // prevents any payload tampering
        if($this->discourseAuthService->isValidPayload($sso, $signature) === false) {
            // TODO: forged payload - handle it here
            abort(400);
        }

        // ensure that the payload has all the necessary
        // data required to create a new payload after
        // authentication
        $payload = null;
        try {
            $payload = $this->discourseAuthService->unpackPayload($sso);
        } catch(BadSSOPayloadException $e) {
            // TODO: missing data from discourse in payload - handle...
            abort(400);
        }

        // store the nonce and return url in a session so
        // the user cannot access or tamper with it at any
        // point during authentication
        $request->session()->put([
            'discourse_nonce'   => $payload['nonce'],
            'discourse_return'  => $payload['return_sso_url'],
        ]);      

        return view('login');
    }

    public function login(Request $request, Validation $validation) {
        $session = $request->session();
        $nonce   = $session->get('discourse_nonce');
        $return  = $session->get('discourse_return');

        if($nonce === null || $return === null) {
            // TODO: payload data missing - handle
            abort(400);
        }

        $validator = $validation->make($request->all(), [
            'email'     => 'required',
            'password'  => 'required',
        ]);

        $validator->after(function($validator) use($request) {
            if($this->auth->attempt([
                'email'     => $request->get('email'),
                'password'  => $request->get('password'),
            ], true) === false) {
    
                $validator->errors()->add('error', 'Email or password is incorrect');
            }
        });

        if($validator->fails()) {
            return redirect()
                ->back()
                ->withErrors($validator->errors())
                ->withInput();
        }


        // generate new payload to send to discourse
        $payload = $this->discourseAuthService->makePayload([
            'nonce' => $nonce,
            'email' => $request->get('email'),
            'external_id' => $this->auth->id(),
            'require_activation' => false,
        ]);
        $signature = $this->discourseAuthService->getSignedPayload($payload);

        // attach parameters to return url
        $endpoint = $this->discourseAuthService->getRedirectUrl($return, $payload, $signature);

        $session->remove('discourse_nonce');
        $session->remove('discourse_return');

        return redirect()->to($endpoint);
    }

    public function logout(Request $request) {
        
    }

}
