<?php

namespace App\Routes\Http\Web\Controllers;

use App\Routes\Http\Web\WebController;
use Illuminate\Validation\Factory as Validation;
use App\Modules\Forums\Services\Authentication\DiscourseAuthService;
use Illuminate\Http\Request;
use Illuminate\Contracts\Auth\Guard as Auth;

class LoginController extends WebController {

    /**
     * @var DiscourseAuthService
     */
    private $discourseAuthService;

    /**
     * @var Auth
     */
    private $auth;


    public function __construct(
        DiscourseAuthService $discourseAuthService,
        Auth $auth
    ) {
        $this->discourseAuthService = $discourseAuthService;
        $this->auth = $auth;
    }

    public function showLoginView(Request $request) {
        // login route should have a valid payload in the url
        // generated by discourse when being redirected here
        $sso        = $request->get('sso');
        $signature  = $request->get('sig');

        if($sso === null || $signature === null) {
            return redirect()->route('front.home');
        }

        // validate that the given signature matches the
        // payload when signed with our private key. This
        // prevents any payload tampering
        $signedPayload = hash_hmac('sha256', $sso, env('DISCOURSE_SSO_SECRET'));

        if($signedPayload !== $signature) {
            // forged payload - handle it here
        }


        $payload = base64_decode($sso);
        $payload = urldecode($payload);

        // ensure that the payload has all the necessary
        // data required to create a new payload after
        // authentication
        parse_str($payload, $discourse);

        if(
            array_key_exists('nonce', $discourse) === false || 
            array_key_exists('return_sso_url', $discourse) === false
        ) {
            // TODO: missing data from discourse in payload - handle...
        }

        // store the nonce and return url in a session so
        // the user cannot access or tamper with it at any
        // point during authentication
        $request->session()->put([
            'discourse_nonce'   => $discourse['nonce'],
            'discourse_return'  => $discourse['return_sso_url'],
        ]);      

        return view('login');
    }

    public function login(Request $request, Validation $validation) {
        $session = $request->session();
        $nonce   = $session->get('discourse_nonce');
        $return  = $session->get('discourse_return');

        if($nonce === null || $return === null) {
            // TODO: payload data missing - handle
        }

        $validator = $validation->make($request->all(), [
            'email'     => 'required',
            'password'  => 'required',
        ]);

        if($validator->fails()) {
            return redirect()
                ->back()
                ->withErrors($validator->errors())
                ->withInput();
        }

        if($this->auth->attempt([
            'email'     => $request->get('email'),
            'password'  => $request->get('password'),
        ], true) === false) {

            return redirect()
                ->back()
                ->withErrors($validator->errors()->add('error', 'Email or password was incorrect'))
                ->withInput();
        }


        // generate new payload to send to discourse
        $payload = [
            'nonce' => $nonce,
            'email' => $request->get('email'),
            'external_id' => $this->auth->id(),
            'require_activation' => false,
        ];
        $payload = http_build_query($payload);

        $encodedPayload = base64_encode($payload);
        $encodedPayload = urlencode($encodedPayload);
        $signedPayload = hash_hmac('sha256', $encodedPayload, env('DISCOURSE_SSO_SECRET'));

        // attach parameters to return url
        $endpoint = $return.'?'.http_build_query([
            'sso' => $encodedPayload,
            'sig' => $signedPayload
        ]);

        $session->remove('discourse_nonce');
        $session->remove('discourse_return');

        return redirect()->to($endpoint);
    }

}
