<?php

namespace Front\Controllers;

use App\Modules\Forums\Exceptions\BadSSOPayloadException;
use App\Modules\Accounts\Services\AccountSocialLinkService;
use App\Modules\Accounts\Services\Login\AccountLoginService;
use App\Modules\Accounts\Services\Login\AccountSocialLoginExecutor;
use App\Modules\Discourse\Services\Api\DiscourseUserApi;
use App\Modules\Discourse\Services\Api\DiscourseAdminApi;
use App\Modules\Discourse\Services\Authentication\DiscourseAuthService;
use App\Modules\Discourse\Services\Authentication\DiscoursePayload;
use Front\Requests\LoginRequest;
use Illuminate\Contracts\Auth\Guard as Auth;
use Illuminate\Http\Request;
use App\Modules\Accounts\Repositories\AccountRepository;
use App\Library\Socialite\SocialiteService;
use App\Modules\Accounts\Exceptions\InvalidDiscoursePayloadException;

class LoginController extends WebController {

    /**
     * @var DiscourseAuthService
     */
    private $discourseAuthService;

    /**
     * @var DiscourseUserApi
     */
    private $discourseUserApi;

    /**
     * @var DiscourseAdminApi
     */
    private $discourseAdminApi;

    /**
     * @var SocialiteService
     */
    private $socialiteService;

    /**
     * @var AccountSocialLinkService
     */
    private $accountLinkService;

    /**
     * @var AccountRepository
     */
    private $accountRepository;

    /**
     * @var Auth
     */
    private $auth;


    public function __construct(DiscourseAuthService $discourseAuthService, 
                                DiscourseUserApi $discourseUserApi,
                                DiscourseAdminApi $discourseAdminApi,
                                SocialiteService $socialiteService,
                                AccountSocialLinkService $accountLinkService,
                                AccountRepository $accountRepository,
                                Auth $auth) 
    {
        $this->discourseAuthService = $discourseAuthService;
        $this->discourseUserApi = $discourseUserApi;
        $this->discourseAdminApi = $discourseAdminApi;
        $this->socialiteService = $socialiteService;
        $this->accountLinkService = $accountLinkService;
        $this->accountRepository = $accountRepository;
        $this->auth = $auth;
    }

    public function showLoginView(Request $request) {
        if ($this->auth->check()) {
            return redirect()->route('front.home');
        }

        // login route should have a valid payload in the url
        // generated by discourse when being redirected here
        $sso        = $request->get('sso');
        $signature  = $request->get('sig');

        if($sso === null || $signature === null) {
            return redirect()->route('front.home');
        }

        // validate that the given signature matches the
        // payload when signed with our private key. This
        // prevents any payload tampering
        $isValidPayload = $this->discourseAuthService->isValidPayload($sso, $signature);
        if($isValidPayload === false) {
            abort(400);
        }

        // ensure that the payload has all the necessary
        // data required to create a new payload after
        // authentication
        $payload = null;
        try {
            $payload = $this->discourseAuthService->unpackPayload($sso);

        } catch(BadSSOPayloadException $e) {
            abort(400);
        }

        // store the nonce and return url in a session so
        // the user cannot access or tamper with it at any
        // point during authentication
        $request->session()->put([
            'discourse_nonce'   => $payload['nonce'],
            'discourse_return'  => $payload['return_sso_url'],
        ]);

        return view('front.pages.login.login');
    }

    /**
     * Manual login with email and password via form post
     *
     * @param LoginRequest $request
     * @return void
     */
    public function login(LoginRequest $request) {
        $session = $request->session();

        $nonce     = $session->get('discourse_nonce');
        $returnUrl = $session->get('discourse_return');

        if($nonce === null || $returnUrl === null) {
            throw new InvalidDiscoursePayloadException('`nonce` or `return` key missing in session');
        }

        $request->validated();

        $account = $this->auth->user();
        if ($account === null) {
            throw new \Exception('Account was null after authentication');
        }

        $payload = (new DiscoursePayload($nonce))
            ->setPcbId($account->getKey())
            ->setEmail($account->email)
            ->requiresActivation(false)
            ->build();
        
        $session->remove('discourse_nonce');
        $session->remove('discourse_return');   
    

        // generate new payload to send to discourse
        $payload    = $this->discourseAuthService->makePayload($payload);
        $signature  = $this->discourseAuthService->getSignedPayload($payload);

        // attach parameters to return url
        $endpoint   = $this->discourseAuthService->getRedirectUrl($returnUrl, $payload, $signature);

        return redirect()->to($endpoint);
    }

    
    public function redirectToFacebook() {
        return $this->redirectToProvider(SocialiteService::FACEBOOK);
    }
    public function redirectToGoogle() {
        return $this->redirectToProvider(SocialiteService::GOOGLE);
    }
    public function redirectToTwitter() {
        return $this->redirectToProvider(SocialiteService::TWITTER);
    }

    private function redirectToProvider(string $providerName) {
        return $this->socialiteService
            ->setProvider($providerName)
            ->redirectToProviderLogin();
    }

    public function handleFacebookCallback(Request $request) {
        return $this->handleProviderCallback(SocialiteService::FACEBOOK, $request);
    }
    public function handleGoogleCallback(Request $request) {
        return $this->handleProviderCallback(SocialiteService::GOOGLE, $request);
    }
    public function handleTwitterCallback(Request $request) {
        return $this->handleProviderCallback(SocialiteService::TWITTER, $request);
    }

    private function handleProviderCallback(string $providerName, Request $request) {
        if ($request->get('denied')) {
            return redirect()->route('front.home');
        }

        $session = $request->session();

        $nonce     = $session->get('discourse_nonce');
        $returnUrl = $session->get('discourse_return');

        if($nonce === null || $returnUrl === null) {
            throw new InvalidDiscoursePayloadException('`nonce` or `return` key missing in session');
        }

        
        $providerAccount = $this->socialiteService
            ->setProvider($providerName)
            ->getProviderResponse();

        $account = $this->accountRepository->getByEmail($providerAccount->getEmail());
        
        // if user does not exist, redirect them to a
        // account creation confirmation page
        if($account === null) {
            $url = URL::temporarySignedRoute('front.login.social-register', now()->addMinutes(10), 
                $provider->toArray()
            );

            return view('front.pages.register.register-oauth', [
                'social' => $provider->toArray(),
                'url'    => $url,
            ]);
        }

        // create account link if one does not exist
        $hasLink = $this->accountLinkService->hasLink($account, $providerName);
        if (!$hasLink) {
            $this->accountLinkService->createLink($account, $providerAccount);
        }


        $this->auth->setUser($account);

        $session->remove('discourse_nonce');
        $session->remove('discourse_return');     

        $payload = (new DiscoursePayload($nonce))
            ->setPcbId($account->getKey())
            ->setEmail($account->email)
            ->requiresActivation(false)
            ->build();
    
        $payload    = $this->discourseAuthService->makePayload($payload);
        $signature  = $this->discourseAuthService->getSignedPayload($payload);

        $url = $this->discourseAuthService->getRedirectUrl($returnUrl, $payload, $signature);
        return redirect()->to($url);
    }

    public function createSocialAccount(Request $request, AccountSocialLoginExecutor $loginHandler) {
        $email      = $request->get('email');
        $id         = $request->get('id');
        $provider   = $request->get('provider');

        if($email === null) {
            abort(400, 'Missing social email');
        }
        if($id === null) {
            abort(400, 'Missing social id');
        }
        if($provider === null) {
            abort(400, 'Missing social provider');
        }

        $account = $this->accountLinkService->createAccount($provider, $email, $id);

        return $loginHandler
            ->setProvider($provider)
            ->setAccount($account)
            ->login($request);
    }

    /**
     * Logs out the current PCB account
     * 
     * (called from Discourse)
     *
     * @param Request $request
     * @return void
     */
    public function logoutFromDiscourse(Request $request) {
        $this->auth->logout();
        return redirect()->route('front.home');
    }

    /**
     * Logs out the current PCB account and
     * its associated Discourse account
     * 
     * (called from this site)
     *
     * @param Request $request
     * @return void
     */
    public function logout(Request $request) {
        if(!$this->auth->check()) {
            return redirect()->route('front.home');
        }

        $externalId = $this->auth->id();
        $result = $this->discourseUserApi->fetchUserByPcbId($externalId);

        $user = $result['user'];
        if($user === null) {
            throw new \Exception('Discourse logout api response did not have a `user` key');
        }

        $this->discourseAdminApi->requestLogout($user['id'], $user['username']);

        $this->auth->logout();
        
        return redirect()->route('front.home');
    }

}
